# 브루트 포스(Brute force)

### 개요

모든 경우의 수를 다 수행해보는 알고리즘이다.<br>

따라서, 경우의 수가 **몇 가지** 나오는지를 파악하는 것이 핵심이 된다.<br>

대표적으로

1. 반복문
2. 순열/조합
3. 재귀 호출
4. 비트마스크

등의 방법이 있다.

전부 시도하는 만큼 정확한 답을 도출하지만, 경우의 수가 너무 많아지면 시간 복잡도로 인해 다른 알고리즘으로 풀 수 있는지를 검토해야 한다.<br>

### 비트마스크(Bitmask)

다음과 같이 정수 하나로 *집합*을 나타낼 수 있다.

집합 `{1, 3, 5, 6, 8}` 이 주어졌을 때, 있으면 1, 없으면 0으로 표기한다.

| 10  |  9  |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  0  |  0  |  1  |  0  |  1  |  1  |  0  |  1  |  0  |  1  |  0  |

= `00101101010₂` = `2⁸ + 2⁶ + 2⁵ + 2³ + 2¹` = `362`

> **_집합(Set)_**<br>
> 집합은 **중복이 없는** 원소들의 모임이다.<br>

이러한 표현은 공간을 적게 사용하며, 정수로 표현하는 것 자체가 큰 장점이 된다.<br>
검사, 추가, 삭제 연산을 위해 집합 전체를 순회할 필요가 없어지기 때문이다.

```
// 예시 1 : 검사 연산 (AND)
// 0을 포함하는지 검사
362 & 2⁰ = 0

// 1을 포함하는지 검사
362 & 2¹ = 2 (10₂)

// 4를 포함하는지 검사
362 & 2⁴ = 0

// 8을 포함하는지 검사
362 & 2⁸ = 256 (10000000₂)

// 예시 2 : 추가 연산 (OR)
// 1 추가
362 | 2¹ = 362 (00101101010₂)

// 4 추가
362 | 2⁴ = 378 (00101111010₂)

// 예시 3 : 삭제 연산 (AND NOT)
// 1 삭제
362 & ~2¹ = 360 (00101101000₂)

// 4 삭제
362 & ~2⁴ = 362 (00101101010₂)
```

보통 0부터 N-1까지 정수로 이루어진 집합을 나타낼 때 사용하며, N의 크기에 따라 제한이 있을 수 있다.

이 때 전체 집합은 `(1 << N) - 1`, 공집합은 `0`으로 표현 가능하다.

🔗 [비트 연산](https://github.com/CHOO-O/CHOO-study/blob/main/CS/Bitwise-operation.md)
